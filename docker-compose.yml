networks:
  delivery-network:
    driver: bridge

volumes:
  pgdata:
  celerybeat:
  logs:


services:
  api:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    env_file: .env
    ports: [ "8000:8000" ]
    command: >
      sh -c "python scripts/init_db.py &&
             uvicorn resources.app:app --host 0.0.0.0 --port 8000 --reload"
    environment:
      PYTHONPATH: /app
      DYNACONF_ENV: development
      PYTHONUNBUFFERED: "1"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    volumes:
      - logs:/app/logs
    networks:
      - delivery-network
    restart: unless-stopped

  worker:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    env_file: .env
    command: [ "celery", "-A", "adapters.messaging.celery_app.celery", "worker", "-l", "info", "-Q", "celery", "--hostname=delivery-worker@%h" ]
    environment:
      PYTHONPATH: /app
      DYNACONF_ENV: development
      PYTHONUNBUFFERED: "1"
    depends_on:
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    volumes:
      - logs:/app/logs
    networks:
      - delivery-network
    restart: unless-stopped

  celery_beat:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    env_file: .env
    command: [ "celery", "-A", "adapters.messaging.celery_app.celery", "beat", "-l", "info" ]
    environment:
      PYTHONPATH: /app
      DYNACONF_ENV: development
      PYTHONUNBUFFERED: "1"
    depends_on:
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    volumes:
      - celerybeat:/var/run/celery # для файла планировщика Celery Beat
      - logs:/app/logs
    networks:
      - delivery-network
    restart: unless-stopped

  flower:
    image: mher/flower:1.2.0
    env_file: .env
    # используем celery flower напрямую
    command: >
      celery flower --port=5555 --broker=${DYNACONF_RABBITMQ__URL} --persistent=True
    ports: [ "5555:5555" ]
    depends_on:
      rabbitmq:
        condition: service_healthy
    networks:
      - delivery-network
    restart: unless-stopped

  db:
    image: postgres:16
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: delivery
    volumes:
      - pgdata:/var/lib/postgresql/data
    # Убираем проброс порта БД наружу - только внутренняя сеть
    expose:
      - "5432"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U app -d delivery" ]
      interval: 5s
      timeout: 3s
      retries: 20
    networks:
      - delivery-network
    restart: unless-stopped

  redis:
    image: redis:7
    command: [ "redis-server", "--appendonly", "yes" ]
    # Убираем проброс порта Redis наружу - только внутренняя сеть
    expose:
      - "6379"
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 5s
      timeout: 3s
      retries: 20
    networks:
      - delivery-network
    restart: unless-stopped

  rabbitmq:
    image: rabbitmq:3.13-management
    environment:
      # если переменные не заданы в .env — будет guest/guest
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER:-guest}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS:-guest}
    # Убираем проброс портов RabbitMQ наружу - только внутренняя сеть  
    expose:
      - "5672"
      - "15672"
    healthcheck:
      test: [ "CMD", "rabbitmq-diagnostics", "-q", "ping" ]
      interval: 5s
      timeout: 3s
      retries: 30
    networks:
      - delivery-network
    restart: unless-stopped
